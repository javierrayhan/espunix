#include <Arduino.h>
#include <time.h>
#include <sys/time.h>
#include <stdarg.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"

// --------- DMESG (circular log buffer) ---------
#define DMESG_MAX_ENTRIES 128
#define DMESG_MAX_ENTRY_LEN 160

static char dmesg_buf[DMESG_MAX_ENTRIES][DMESG_MAX_ENTRY_LEN];
static uint16_t dmesg_head = 0;   // next write index
static uint16_t dmesg_count = 0;  // how many valid entries stored (<= DMESG_MAX_ENTRIES)
static portMUX_TYPE dmesg_mux = portMUX_INITIALIZER_UNLOCKED; // protect on SMP cores

// log_event: printf-style logger that stores to ring buffer with timestamp
void log_event(const char* fmt, ...) {
    char tmp[DMESG_MAX_ENTRY_LEN];
    // add timestamp
    struct timeval tv;
    gettimeofday(&tv, NULL);
    time_t now_s = tv.tv_sec;
    struct tm tm;
    localtime_r(&now_s, &tm);
    int len = strftime(tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S", &tm);

    // append microsecond + space
    len += snprintf(tmp+len, sizeof(tmp)-len, ".%06ld ", (long)tv.tv_usec);

    // append user message
    va_list ap;
    va_start(ap, fmt);
    vsnprintf(tmp + len, sizeof(tmp) - len, fmt, ap);
    va_end(ap);

    // store to ring buffer (protected)
    taskENTER_CRITICAL(&dmesg_mux);
    strncpy(dmesg_buf[dmesg_head], tmp, DMESG_MAX_ENTRY_LEN-1);
    dmesg_buf[dmesg_head][DMESG_MAX_ENTRY_LEN-1] = '\0';
    dmesg_head = (dmesg_head + 1) % DMESG_MAX_ENTRIES;
    if (dmesg_count < DMESG_MAX_ENTRIES) dmesg_count++;
    taskEXIT_CRITICAL(&dmesg_mux);
}

// cmd_dmesg: print logs from oldest->newest
void cmd_dmesg(char* args) {
    Serial.println("=== dmesg (oldest -> newest) ===");
    taskENTER_CRITICAL(&dmesg_mux);
    uint16_t start = (dmesg_head + DMESG_MAX_ENTRIES - dmesg_count) % DMESG_MAX_ENTRIES;
    for (uint16_t i=0; i<dmesg_count; i++) {
        uint16_t idx = (start + i) % DMESG_MAX_ENTRIES;
        Serial.println(dmesg_buf[idx]);
    }
    taskEXIT_CRITICAL(&dmesg_mux);
    Serial.println("=== end dmesg ===");
}

// optional: clear buffer
void cmd_dmesg_clear(char* args) {
    taskENTER_CRITICAL(&dmesg_mux);
    dmesg_count = 0;
    dmesg_head = 0;
    taskEXIT_CRITICAL(&dmesg_mux);
    Serial.println("dmesg cleared");
}

// --------- DATE command (view + set) ---------
// Format for set: date set YYYY-MM-DD HH:MM:SS
// Examples:
//   date              -> show current time
//   date set 2025-10-30 14:20:00

static bool parse_datetime(const char* sdate, const char* stime, struct tm &out_tm) {
    // sdate: "YYYY-MM-DD"
    // stime: "HH:MM:SS"
    int Y, M, D, h, m, sec;
    if (sscanf(sdate, "%d-%d-%d", &Y, &M, &D) != 3) return false;
    if (sscanf(stime, "%d:%d:%d", &h, &m, &sec) != 3) return false;
    memset(&out_tm, 0, sizeof(out_tm));
    out_tm.tm_year = Y - 1900;
    out_tm.tm_mon  = M - 1;
    out_tm.tm_mday = D;
    out_tm.tm_hour = h;
    out_tm.tm_min  = m;
    out_tm.tm_sec  = sec;
    return true;
}

void print_current_time() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    time_t now_s = tv.tv_sec;
    struct tm tm;
    localtime_r(&now_s, &tm);
    char buf[64];
    strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", &tm);
    Serial.printf("Current time: %s.%06ld\n", buf, (long)tv.tv_usec);
}

// cmd_date: no args -> show time; "set YYYY-MM-DD HH:MM:SS" -> set time
void cmd_date(char* args) {
    if (!args || strlen(args) == 0) {
        print_current_time();
        return;
    }
    // trim leading spaces
    while (*args == ' ') args++;
    if (strncmp(args, "set", 3) == 0) {
        // skip "set"
        char *p = args + 3;
        while (*p == ' ') p++;
        // expect two tokens: date and time
        char sdate[32] = {0}, stime[32] = {0};
        int n = sscanf(p, "%31s %31s", sdate, stime);
        if (n != 2) {
            Serial.println("Usage: date set YYYY-MM-DD HH:MM:SS");
            return;
        }
        struct tm tm;
        if (!parse_datetime(sdate, stime, tm)) {
            Serial.println("Bad date/time format. Use YYYY-MM-DD HH:MM:SS");
            return;
        }
        time_t t = mktime(&tm); // assumes local TZ (usually UTC if not set)
        if (t == (time_t)-1) {
            Serial.println("mktime failed");
            return;
        }
        struct timeval tv = { .tv_sec = t, .tv_usec = 0 };
        if (settimeofday(&tv, NULL) == 0) {
            Serial.println("System time updated");
            char tmp[64];
            strftime(tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S", &tm);
            // also log to dmesg
            log_event("date set %s %s", sdate, stime);
            Serial.printf("New time: %s\n", tmp);
        } else {
            Serial.println("Failed to set time (settimeofday returned error)");
        }
        return;
    }
    // unknown subcommand
    Serial.println("Unknown date command. Usage:");
    Serial.println("  date                     # show current time");
    Serial.println("  date set YYYY-MM-DD HH:MM:SS   # set time");
}

// ------------ Example usage & initial logs -------------
void setup() {
    Serial.begin(115200);
    delay(500);
    // seed default TZ to UTC if you want (optional)
    // setenv("TZ", "UTC0", 1); tzset();

    // register commands in your CLI system, example:
    // registerCommand("dmesg", cmd_dmesg, "Display kernel/startup logs");
    // registerCommand("dmesg_clear", cmd_dmesg_clear, "Clear dmesg buffer");
    // registerCommand("date", cmd_date, "View or set system time");
    Serial.println("CLI ready. Commands: dmesg, dmesg_clear, date");

    // example initial logs
    log_event("system boot");
    log_event("CLI initialized");
}

void loop() {
    // keep loop light if CLI runs in separate task
    vTaskDelay(1000 / portTICK_PERIOD_MS);
}